require 'test/FbTestCases'

class ReturningTestCases < FbTestCase
  include FbTestCases

  def test_insert_returning_single_column
    sql_schema = 'CREATE TABLE TEST_RETURNING (ID INT, NAME VARCHAR(20))'
    sql_insert = 'INSERT INTO TEST_RETURNING (NAME) VALUES (?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'John')

      assert_instance_of Hash, result, "RETURNING not working - got #{result.class}"
      assert result.key?(:returning), 'Result should have :returning key'
      assert result.key?(:rows_affected), 'Result should have :rows_affected key'

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 1, returning.size
      assert_kind_of Integer, returning[0]

      assert_equal 1, result[:rows_affected]

      row = connection.query('SELECT * FROM TEST_RETURNING').first
      assert_equal 'John', row[1]
    end
  end

  def test_insert_returning_with_params
    sql_schema = 'CREATE TABLE TEST_RETURNING (ID INT, NAME VARCHAR(20), EMAIL VARCHAR(50))'
    sql_insert = 'INSERT INTO TEST_RETURNING (NAME, EMAIL) VALUES (?, ?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'John', 'john@example.com')

      assert_instance_of Hash, result, "RETURNING not working - got #{result.class}"

      assert_equal 1, result[:rows_affected]

      returning = result[:returning]
      assert_equal 1, returning.size

      id = returning[0]
      row = connection.query('SELECT * FROM TEST_RETURNING WHERE ID = ?', id).first
      assert_equal 'John', row[1]
      assert_equal 'john@example.com', row[2]
    end
  end

  def test_insert_returning_multiple_columns
    sql_schema = 'CREATE TABLE TEST_RETURNING_MULTI (ID INT GENERATED BY DEFAULT AS IDENTITY, NAME VARCHAR(20), CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP)'
    sql_insert = 'INSERT INTO TEST_RETURNING_MULTI (NAME) VALUES (?) RETURNING ID, CREATED_AT'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'Test Name')

      assert_instance_of Hash, result
      assert result.key?(:returning)

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 2, returning.size, "Should return 2 columns (ID and CREATED_AT)"

      assert_kind_of Integer, returning[0], "First column (ID) should be Integer"
      assert returning[1].is_a?(Time) || returning[1].is_a?(DateTime), "Second column (CREATED_AT) should be Time/DateTime"

      assert_equal 1, result[:rows_affected]
    end
  end

  def test_update_returning
    sql_schema = 'CREATE TABLE TEST_UPDATE_RET (ID INT, NAME VARCHAR(20), COUNTER INT)'
    sql_insert = 'INSERT INTO TEST_UPDATE_RET (ID, NAME, COUNTER) VALUES (?, ?, ?)'
    sql_update = 'UPDATE TEST_UPDATE_RET SET COUNTER = COUNTER + 1 WHERE ID = ? RETURNING NAME, COUNTER'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)
      connection.execute(sql_insert, 1, 'Initial', 0)

      result = connection.execute(sql_update, 1)

      assert_instance_of Hash, result
      assert result.key?(:returning)

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 2, returning.size
      assert_equal 'Initial', returning[0]
      assert_equal 1, returning[1]

      assert_equal 1, result[:rows_affected]
    end
  end

  def test_delete_returning
    sql_schema = 'CREATE TABLE TEST_DELETE_RET (ID INT, NAME VARCHAR(20))'
    sql_insert = 'INSERT INTO TEST_DELETE_RET (ID, NAME) VALUES (?, ?)'
    sql_delete = 'DELETE FROM TEST_DELETE_RET WHERE ID = ? RETURNING NAME'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)
      connection.execute(sql_insert, 1, 'ToDelete')

      result = connection.execute(sql_delete, 1)

      assert_instance_of Hash, result
      assert result.key?(:returning)

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 1, returning.size
      assert_equal 'ToDelete', returning[0]

      assert_equal 1, result[:rows_affected]

      # Verify row was deleted
      remaining = connection.query('SELECT COUNT(*) FROM TEST_DELETE_RET').first[0]
      assert_equal 0, remaining
    end
  end

  def test_insert_returning_with_null_value
    sql_schema = 'CREATE TABLE TEST_NULL_RET (ID INT, NAME VARCHAR(20), DESCRIPTION VARCHAR(100))'
    sql_insert = 'INSERT INTO TEST_NULL_RET (ID, NAME) VALUES (?, ?) RETURNING DESCRIPTION'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 1, 'Test')

      assert_instance_of Hash, result
      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 1, returning.size
      assert_nil returning[0], "NULL value should be returned as nil"
    end
  end

  def test_insert_returning_no_matching_rows
    sql_schema = 'CREATE TABLE TEST_NO_MATCH (ID INT PRIMARY KEY, NAME VARCHAR(20))'
    sql_insert = 'INSERT INTO TEST_NO_MATCH (ID, NAME) VALUES (?, ?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      # Insert first row
      result = connection.execute(sql_insert, 1, 'First')
      assert_equal 1, result[:rows_affected]

      # This should work fine - RETURNING with successful insert
      assert result[:returning].size > 0
    end
  end

  def test_update_returning_no_rows_affected
    sql_schema = 'CREATE TABLE TEST_UPDATE_ZERO (ID INT, NAME VARCHAR(20))'
    sql_update = 'UPDATE TEST_UPDATE_ZERO SET NAME = ? WHERE ID = ? RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      # Update with no matching rows
      result = connection.execute(sql_update, 'NewName', 999)

      assert_instance_of Hash, result
      assert_equal 0, result[:rows_affected]
      # RETURNING should return empty array when no rows match
      assert result[:returning].is_a?(Array)
    end
  end
end
