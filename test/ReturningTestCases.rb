require 'test/FbTestCases'

class ReturningTestCases < FbTestCase
  include FbTestCases

  def test_insert_returning_single_column
    # ID uses IDENTITY so Firebird assigns it automatically
    sql_schema = 'CREATE TABLE TEST_RETURNING (ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, NAME VARCHAR(20))'
    sql_insert = 'INSERT INTO TEST_RETURNING (NAME) VALUES (?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'John')

      assert_instance_of Hash, result, "RETURNING not working - got #{result.class}"
      assert result.key?(:returning), 'Result should have :returning key'
      assert result.key?(:rows_affected), 'Result should have :rows_affected key'

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 1, returning.size
      assert_kind_of Integer, returning[0], "ID should be an Integer, got #{returning[0].inspect}"
      assert returning[0] > 0, "Generated ID should be > 0"

      assert_equal 1, result[:rows_affected]

      row = connection.query('SELECT * FROM TEST_RETURNING').first
      assert_equal 'John', row[1]
    end
  end

  def test_insert_returning_with_params
    # ID uses IDENTITY so Firebird assigns it automatically
    sql_schema = 'CREATE TABLE TEST_RETURNING (ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, NAME VARCHAR(20), EMAIL VARCHAR(50))'
    sql_insert = 'INSERT INTO TEST_RETURNING (NAME, EMAIL) VALUES (?, ?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'John', 'john@example.com')

      assert_instance_of Hash, result, "RETURNING not working - got #{result.class}"
      assert_equal 1, result[:rows_affected]

      returning = result[:returning]
      assert_equal 1, returning.size

      id = returning[0]
      assert_kind_of Integer, id, "Returned ID should be Integer, got #{id.inspect}"
      assert id > 0, "Generated ID should be > 0"

      row = connection.query('SELECT * FROM TEST_RETURNING WHERE ID = ?', id).first
      assert_not_nil row, "Row with ID=#{id} should exist"
      assert_equal 'John', row[1]
      assert_equal 'john@example.com', row[2]
    end
  end

  def test_insert_returning_multiple_columns
    sql_schema = 'CREATE TABLE TEST_RETURNING_MULTI (ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, NAME VARCHAR(20), CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP)'
    sql_insert = 'INSERT INTO TEST_RETURNING_MULTI (NAME) VALUES (?) RETURNING ID, CREATED_AT'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'Test Name')

      assert_instance_of Hash, result
      assert result.key?(:returning)

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 2, returning.size, "Should return 2 columns (ID and CREATED_AT)"

      assert_kind_of Integer, returning[0], "First column (ID) should be Integer"
      assert returning[0] > 0, "Generated ID should be > 0"
      assert returning[1].is_a?(Time) || returning[1].is_a?(DateTime), \
        "Second column (CREATED_AT) should be Time/DateTime, got #{returning[1].class}"

      assert_equal 1, result[:rows_affected]
    end
  end

  def test_update_returning
    sql_schema = 'CREATE TABLE TEST_UPDATE_RET (ID INT, NAME VARCHAR(20), COUNTER INT)'
    sql_insert = 'INSERT INTO TEST_UPDATE_RET (ID, NAME, COUNTER) VALUES (?, ?, ?)'
    sql_update = 'UPDATE TEST_UPDATE_RET SET COUNTER = COUNTER + 1 WHERE ID = ? RETURNING NAME, COUNTER'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)
      connection.execute(sql_insert, 1, 'Initial', 0)

      result = connection.execute(sql_update, 1)

      assert_instance_of Hash, result
      assert result.key?(:returning)

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 2, returning.size
      assert_equal 'Initial', returning[0].rstrip  # CHAR fields may be padded
      assert_equal 1, returning[1]

      assert_equal 1, result[:rows_affected]
    end
  end

  def test_delete_returning
    sql_schema = 'CREATE TABLE TEST_DELETE_RET (ID INT, NAME VARCHAR(20))'
    sql_insert = 'INSERT INTO TEST_DELETE_RET (ID, NAME) VALUES (?, ?)'
    sql_delete = 'DELETE FROM TEST_DELETE_RET WHERE ID = ? RETURNING NAME'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)
      connection.execute(sql_insert, 1, 'ToDelete')

      result = connection.execute(sql_delete, 1)

      assert_instance_of Hash, result
      assert result.key?(:returning)

      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 1, returning.size
      assert_equal 'ToDelete', returning[0]

      assert_equal 1, result[:rows_affected]

      # Verify row was actually deleted
      remaining = connection.query('SELECT COUNT(*) FROM TEST_DELETE_RET').first[0]
      assert_equal 0, remaining
    end
  end

  def test_insert_returning_with_null_value
    sql_schema = 'CREATE TABLE TEST_NULL_RET (ID INT, NAME VARCHAR(20), DESCRIPTION VARCHAR(100))'
    sql_insert = 'INSERT INTO TEST_NULL_RET (ID, NAME) VALUES (?, ?) RETURNING DESCRIPTION'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 1, 'Test')

      assert_instance_of Hash, result
      returning = result[:returning]
      assert_instance_of Array, returning
      assert_equal 1, returning.size
      assert_nil returning[0], "NULL value should be returned as nil"
    end
  end

  def test_insert_returning_no_matching_rows
    # Verifies that a successful INSERT RETURNING still works correctly
    sql_schema = 'CREATE TABLE TEST_NO_MATCH (ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, NAME VARCHAR(20))'
    sql_insert = 'INSERT INTO TEST_NO_MATCH (NAME) VALUES (?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 'First')
      assert_instance_of Hash, result
      assert_equal 1, result[:rows_affected]
      assert result[:returning].size > 0, "RETURNING should have at least one value"
      assert result[:returning][0] > 0, "Generated ID should be positive"
    end
  end

  def test_update_returning_no_rows_affected
    sql_schema = 'CREATE TABLE TEST_UPDATE_ZERO (ID INT, NAME VARCHAR(20))'
    sql_update = 'UPDATE TEST_UPDATE_ZERO SET NAME = ? WHERE ID = ? RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      # Update with no matching rows â€” RETURNING returns empty
      result = connection.execute(sql_update, 'NewName', 999)

      assert_instance_of Hash, result
      assert_equal 0, result[:rows_affected]
      assert_instance_of Array, result[:returning]
      # No rows matched, so returning array should be empty
      assert result[:returning].empty?, "RETURNING should be empty when no rows matched"
    end
  end

  def test_insert_returning_result_is_not_cursor
    # Verifies that RETURNING does not accidentally leave an open cursor
    sql_schema = 'CREATE TABLE TEST_NOT_CURSOR (ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, VAL INT)'
    sql_insert = 'INSERT INTO TEST_NOT_CURSOR (VAL) VALUES (?) RETURNING ID'

    Database.create(@parms) do |connection|
      connection.execute(sql_schema)

      result = connection.execute(sql_insert, 42)
      assert_instance_of Hash, result, "Expected Hash from RETURNING, got #{result.class}"

      # Should be able to execute another statement immediately (no open cursor blocking)
      result2 = connection.execute(sql_insert, 99)
      assert_instance_of Hash, result2
      assert_equal 1, result2[:rows_affected]
    end
  end
end
